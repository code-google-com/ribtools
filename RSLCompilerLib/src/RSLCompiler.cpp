//==================================================================
/// RSLCompiler.cpp
///
/// Created by Davide Pasca - 2009/5/21
/// See the file "license.txt" that comes with this project for
/// copyright info. 
//==================================================================

#include <time.h>
#include "DSystem/include/DUtils.h"
#include "DSystem/include/DContainers.h"
#include "RSLC_Token.h"
#include "RSLC_Tree.h"
#include "RSLC_Variables.h"
#include "RSLCompiler.h"

//==================================================================
using namespace	RSLC;

//==================================================================
const char	*RSLCompiler::mpsVersionString = "0.1a";

//==================================================================
RSLCompiler::RSLCompiler( const char *pSource, size_t sourceSize )
{
	Tokenizer( mTokens, pSource, sourceSize );

	for (size_t i=0; i < mTokens.size(); ++i)
	{
		printf( "%3i) %i - %-12s - %s\n",
				i,
				mTokens[i].isPrecededByWS,
				GetTokenTypeStr( mTokens[i].idType ),
				mTokens[i].str.c_str() );
	}

	mpRoot = MakeTree( mTokens );

	DiscoverVariables( mpRoot );

	TraverseTree( mpRoot, 0 );
}

//==================================================================
RSLCompiler::~RSLCompiler()
{

}

//==================================================================
static void scanSaveVars( FILE *pFile, TokNode *pNode, size_t &blockCnt )
{
	const DVec<Variable> &vars = pNode->GetVars();

	if ( vars.size() )
	{
		fprintf_s( pFile, "\t; -- vars for block %i\n", blockCnt );

		for (size_t i=0; i < vars.size(); ++i)
		{
			const Variable	&var = vars[i];

			fprintf_s( pFile, "\t" );

			fprintf_s( pFile, "%-18s", var.mInternalName.c_str() );

			fprintf_s( pFile, "\t" );

			switch ( pNode->mBlockType )
			{
			case BLKT_SHPARAMS:		fprintf_s( pFile, "parameter" );	break;
			case BLKT_CODEBLOCK:	fprintf_s( pFile, "temporary" );	break;
			case BLKT_EXPRESSION:	fprintf_s( pFile, "temporary" );	break;
			}

			fprintf_s( pFile, "\t" );

			if ( var.mIsVarying )
				fprintf_s( pFile, "varying" );
			else
				fprintf_s( pFile, "uniform" );

			if ( var.mpDTypeTok )
			{
				fprintf_s( pFile, "\t" );
				switch ( var.mpDTypeTok->id )
				{
				case T_DT_float:	fprintf_s( pFile, "float" );	break;
				case T_DT_vector:	fprintf_s( pFile, "vector" );	break;
				case T_DT_point:	fprintf_s( pFile, "point" );	break;
				case T_DT_normal:	fprintf_s( pFile, "normal" );	break;
				case T_DT_color:	fprintf_s( pFile, "color" );	break;
				case T_DT_string:	fprintf_s( pFile, "string" );	break;

				default:
					throw Exception( "Bad type ?!", var.mpDTypeTok );
					break;
				}
			}

			fprintf_s( pFile, "\n" );
		}

		blockCnt += 1;
		fprintf_s( pFile, "\n" );
	}


	for (size_t i=0; i < pNode->mpChilds.size(); ++i)
	{
		scanSaveVars( pFile, pNode->mpChilds[i], blockCnt );
	}
}

//==================================================================
void RSLCompiler::SaveASM( const char *pFName, const char *pRefSourceName )
{
	FILE	*pFile;

	if ( fopen_s( &pFile, pFName, "wb" ) )
	{
		DASSTHROW( 0, ("Failed to save %s", pFName) );
	}

	char dateStr[256];
	char timeStr[256];
	_strdate_s( dateStr);
	_strtime_s( timeStr );

	fprintf_s( pFile, ";==========================================================\n" );
	fprintf_s( pFile, ";= %s\n", pFName );
	fprintf_s( pFile, ";= Source file %s\n", pRefSourceName );
	fprintf_s( pFile, ";= Creation date %s - %s\n", dateStr, timeStr );
	fprintf_s( pFile, ";= File automatically generated by RSLCompilerCmd %s\n", mpsVersionString );
	fprintf_s( pFile, ";=========================================================\n\n" );

	size_t	blockCnt = 0;
	scanSaveVars( pFile, mpRoot, blockCnt );

	fclose( pFile );
}

