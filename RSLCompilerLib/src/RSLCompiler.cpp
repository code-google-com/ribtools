//==================================================================
/// RSLCompiler.cpp
///
/// Created by Davide Pasca - 2009/5/21
/// See the file "license.txt" that comes with this project for
/// copyright info. 
//==================================================================

#include <time.h>
#include "DSystem/include/DUtils.h"
#include "DSystem/include/DContainers.h"
#include "RSLC_Token.h"
#include "RSLC_Tree.h"
#include "RSLC_Variables.h"
#include "RSLC_Functions.h"
#include "RSLCompiler.h"

//==================================================================
using namespace	RSLC;

//==================================================================
namespace RSLC
{

//==================================================================
static void unlinkNodeFromParent( TokNode *pNode )
{
	if NOT( pNode->mpParent )
		return;

	for (size_t i=0; i < pNode->mpParent->mpChilds.size(); ++i)
	{
		if ( pNode->mpParent->mpChilds[i] == pNode )
		{
			pNode->mpParent->mpChilds.erase( pNode->mpParent->mpChilds.begin()+i );
			return;
		}
	}

	DASSERT( 0 );
}

//==================================================================
static void reparentNode( TokNode *pNode, TokNode *pNewParent )
{
	unlinkNodeFromParent( pNode );
	pNode->mpParent = pNewParent;
}

//==================================================================
static bool expandExpressions( TokNode *pNode )
{
	if ( pNode->mpToken && pNode->mpToken->id == T_OP_ASSIGN )
	{
		TokNode	*pLValue = pNode->GetLeft();
		//if NOT( pLValue )
		//	throw Exception( "Missing left value in expression assignment.", pNode->mpToken );

		/*
		{
			a	=	b


		{
				=
			a		b
		*/

		if ( pLValue )
		{
			reparentNode( pLValue, pNode );
			pNode->mpChilds.push_front( pLValue );
		}
	}

	for (size_t i=0; i < pNode->mpChilds.size(); ++i)
	{
		expandExpressions( pNode->mpChilds[i] );
	}

	return true;
}

//==================================================================
}

//==================================================================
const char	*RSLCompiler::mpsVersionString = "0.1a";

//==================================================================
RSLCompiler::RSLCompiler( const char *pSource, size_t sourceSize )
{
	Tokenizer( mTokens, pSource, sourceSize );

	for (size_t i=0; i < mTokens.size(); ++i)
	{
		printf( "%3i) %i - %-12s - %s\n",
				i,
				mTokens[i].isPrecededByWS,
				GetTokenTypeStr( mTokens[i].idType ),
				mTokens[i].str.c_str() );
	}

	mpRoot = MakeTree( mTokens );

	DiscoverVariables( mpRoot );

	DiscoverFunctions( mpRoot );

	expandExpressions( mpRoot );

	TraverseTree( mpRoot, 0 );
}

//==================================================================
RSLCompiler::~RSLCompiler()
{
}

//==================================================================
void RSLCompiler::SaveASM( const char *pFName, const char *pRefSourceName )
{
	FILE	*pFile;

	if ( fopen_s( &pFile, pFName, "wb" ) )
	{
		DASSTHROW( 0, ("Failed to save %s", pFName) );
	}

	char dateStr[256];
	char timeStr[256];
	_strdate_s( dateStr);
	_strtime_s( timeStr );

	fprintf_s( pFile, ";==========================================================\n" );
	fprintf_s( pFile, ";= %s\n", pFName );
	fprintf_s( pFile, ";= Source file %s\n", pRefSourceName );
	fprintf_s( pFile, ";= Creation date %s - %s\n", dateStr, timeStr );
	fprintf_s( pFile, ";= File automatically generated by RSLCompilerCmd %s\n", mpsVersionString );
	fprintf_s( pFile, ";=========================================================\n\n" );

	fprintf_s( pFile, "\n.data\n" );

	WriteVariables( pFile, mpRoot );

	fprintf_s( pFile, "\n.code\n" );

	WriteFunctions( pFile, mpRoot );

	fclose( pFile );
}

